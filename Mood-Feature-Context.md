Mood-Feature-Context.md
Introduction
This document serves as a comprehensive guide for implementing a mood-based task suggestion feature in our productivity application. The feature allows users to input their current mood via a terminal command, receive a personalized task suggestion generated by an AI, and decide whether to accept or decline the task through a popup window. Accepted tasks are then integrated into the user's normal quest list. This guide is designed for another AI or developer to follow, providing explicit instructions, code examples, and reasoning to ensure seamless integration into the existing project.

Feature Overview
The mood-based task suggestion feature enhances user engagement by tailoring tasks to the user's emotional state and profile. Here's how it works:

Mood Input: Users enter a command (!mood) in the terminal, followed by their current mood (e.g., "happy," "stressed").
AI Processing: The AI analyzes the mood alongside user data (e.g., level, rank, age, gender, completed quests) to suggest a relevant task.
Task Display: A popup window shows the suggested task with "Accept" and "Decline" options.
Quest Integration: If accepted, the task is added to the user's normal quests, stored in Firebase, and displayed in the quests window.
This feature builds on the app's existing terminal interface, AI system, window management, and Firebase-backed quest system.

Prerequisites
Before starting, ensure you understand the following components of the project:

Terminal Interface: User commands are entered in a text input field and processed via a commands object.
Command Handling: The input element listens for "Enter" keypresses to execute commands.
AI System: The SoloAISystem class calls an external API (e.g., DeepSeek) with a prompt and processes the response.
Window System: The windowSystem manages popup windows like questsWindow and notesWindow.
Quest System: Quests are stored in Firebase under players/{userId}/quests and displayed in the UI.
Player Data: User stats (e.g., level, rank, profile) are stored in playerStats and synced with Firebase.
Authentication: Users must be authenticated (isAuthenticated flag) to use features.
You’ll also need access to Firebase and the AI API credentials.

Implementation Steps
Step 1: Add the Mood Input Command
Objective: Allow users to initiate the feature with a command.

Instructions:

Open the file where the commands object is defined (likely commands.js or main.js).
Add a new command, !mood, to the commands object.
Define a global variable awaitingMood (initially false) to track when the app expects a mood input.
In the command function, check if the user is authenticated, set awaitingMood to true, and prompt the user to enter their mood.
Code Example:








// At the top of the file
let awaitingMood = false;

// Inside the commands object
commands["!mood"] = () => {
  if (!isAuthenticated) {
    printToTerminal("You must !reawaken first.", "error");
    return;
  }
  awaitingMood = true;
  printToTerminal("Enter your current mood (e.g., happy, stressed, tired):", "info");
};
Explanation:

isAuthenticated ensures only logged-in users can use the feature, consistent with other commands.
awaitingMood acts as a state flag, signaling that the next input should be treated as the mood.
printToTerminal provides feedback, guiding the user on what to do next.
Step 2: Capture and Process Mood Input
Objective: Detect and handle the mood input after the !mood command.

Instructions:

Locate the input event listener (likely in main.js or ui.js) that processes terminal inputs.
Add a condition to check if awaitingMood is true.
If true, capture the input as the mood, reset awaitingMood, validate the input, and trigger the next step.
Code Example:








input.addEventListener("keypress", async (e) => {
  if (e.key === "Enter") {
    const value = input.value.trim();
    input.value = ""; // Clear the input field
    
    if (awaitingMood) {
      awaitingMood = false;
      const mood = value;
      if (!mood) {
        printToTerminal("Please enter a mood.", "warning");
        return;
      }
      printToTerminal(`Mood recorded: ${mood}. Generating suggestion...`, "success");
      await handleMoodSuggestion(mood); // Define this function next
    } else {
      // Existing command handling logic
      const commandFunc = commands[value.split(" ")[0]];
      if (commandFunc) commandFunc(value);
      else printToTerminal("Unknown command.", "error");
    }
  }
});
Explanation:

The if (awaitingMood) block intercepts the input when the flag is set.
Empty input is rejected to ensure valid data is passed to the AI.
handleMoodSuggestion will orchestrate the next steps (data collection and AI call).
Step 3: Gather User Data for the AI
Objective: Collect user stats and recent quests to provide context for the AI.

Instructions:

Create a new function, handleMoodSuggestion, to process the mood and gather data.
Access playerStats for level, rank, and profile details (age, gender).
Query Firebase for the user’s last 5 completed quests.
Handle missing data gracefully with defaults.
Code Example:








async function handleMoodSuggestion(mood) {
  const playerRef = db.collection("players").doc(currentUser.uid);
  const completedQuestsSnapshot = await playerRef.collection("quests")
    .where("completed", "==", true)
    .orderBy("completedAt", "desc")
    .limit(5)
    .get();
  
  const completedQuests = completedQuestsSnapshot.docs
    .map(doc => doc.data().title)
    .join(", ") || "none";

  const userData = {
    mood: mood,
    level: playerStats.level || 1,
    rank: playerStats.rank || "Novice",
    age: playerStats.profile?.age || "unknown",
    gender: playerStats.profile?.gender || "unknown",
    completedQuests: completedQuests
  };

  await callAIForSuggestion(userData); // Define this next
}
Explanation:

playerRef targets the current user’s Firebase document.
The query fetches recent quests, ordered by completion time, to avoid repetition in suggestions.
userData consolidates all relevant info, using fallbacks (e.g., 1 for level) if data is missing.
Step 4: Modify the AI Prompt
Objective: Update the AI prompt to incorporate mood and user data, ensuring a structured response.

Instructions:

Locate the SoloAISystem class or wherever the AI prompt is constructed.
Extend the prompt to include the new userData fields.
Specify a response format (Title, Description, Target, Metric) and provide an example.
Code Example:








function constructPrompt(userData) {
  return `
User's current mood: ${userData.mood}
User's level: ${userData.level}
User's rank: ${userData.rank}
User's age: ${userData.age}
User's gender: ${userData.gender}
Recently completed quests: ${userData.completedQuests}

Suggest a productivity task that suits the user's mood and capabilities. The task should be specific, achievable, and relevant to their profile. Avoid suggesting tasks similar to recently completed ones. Format your response as:
Title: [task title]
Description: [task description]
Target: [numerical target, if applicable]
Metric: [unit, if applicable]

Example:
If the user is "stressed" (level 3, rank Novice), suggest:
Title: Deep Breathing Exercise
Description: Practice deep breathing to relax
Target: 5
Metric: minutes
  `;
}
Explanation:

The prompt provides all necessary context to the AI.
The structured format ensures the response is parsable.
An example guides the AI toward the desired output style.
Step 5: Parse the AI Response
Objective: Extract task details from the AI’s response for display and storage.

Instructions:

In SoloAISystem, add a function to parse the AI response.
Use string splitting to extract fields based on the expected format.
Validate the response and handle incomplete data.
Code Example:








function parseTaskSuggestion(response) {
  const lines = response.trim().split("\n");
  const task = {};
  
  lines.forEach(line => {
    if (line.startsWith("Title:")) task.title = line.replace("Title:", "").trim();
    else if (line.startsWith("Description:")) task.description = line.replace("Description:", "").trim();
    else if (line.startsWith("Target:")) task.target = parseInt(line.replace("Target:", "").trim(), 10);
    else if (line.startsWith("Metric:")) task.metric = line.replace("Metric:", "").trim();
  });

  if (!task.title || !task.description) {
    throw new Error("Incomplete task suggestion from AI");
  }
  
  return task;
}
Explanation:

The function splits the response into lines and maps them to a task object.
Validation ensures the task has a title and description (required fields).
Target and Metric are optional and parsed only if present.
Step 6: Create the Task Suggestion Window
Objective: Build a popup window to display the task and capture user input.

Instructions:

Add HTML for the window in your main HTML file or dynamically create it in .
Register it with windowSystem (e.g., windowSystem.addWindow).
Style it consistently with other windows (e.g., using CSS classes like .window).
Code Example (HTML):

html






<div id="taskSuggestionWindow" class="window" style="display: none;">
  <div class="window-header">
    <span>Suggested Task</span>
    <button class="window-close">×</button>
  </div>
  <div class="window-content">
    <p><strong>Title:</strong> <span id="suggestedTitle"></span></p>
    <p><strong>Description:</strong> <span id="suggestedDescription"></span></p>
    <p><strong>Target:</strong> <span id="suggestedTarget"></span> <span id="suggestedMetric"></span></p>
  </div>
  <div class="window-actions">
    <button id="acceptTask">Accept</button>
    <button id="declineTask">Decline</button>
  </div>
</div>
CSS Example:

css






.window {
  position: absolute;
  background: #1a1a1a;
  color: #fff;
  border: 1px solid #444;
  padding: 10px;
  width: 300px;
}
.window-header {
  display: flex;
  justify-content: space-between;
}
.window-actions {
  margin-top: 10px;
  text-align: right;
}
Explanation:

The window mimics the style of existing windows for consistency.
IDs like suggestedTitle allow dynamic content updates.
Step 7: Implement Window Logic
Objective: Populate the window with task details and handle user decisions.

Instructions:

Create a function, showTaskSuggestion, to display the window and set up button actions.
Use windowSystem.showWindow to display it.
On "Accept," call the existing createQuest function; on "Decline," close the window.
Code Example:








async function showTaskSuggestion(task) {
  const window = windowSystem.showWindow("taskSuggestionWindow");
  
  document.getElementById("suggestedTitle").textContent = task.title;
  document.getElementById("suggestedDescription").textContent = task.description;
  document.getElementById("suggestedTarget").textContent = task.target || "N/A";
  document.getElementById("suggestedMetric").textContent = task.metric || "";

  document.getElementById("acceptTask").onclick = async () => {
    await createQuest({
      type: "normal",
      title: task.title,
      description: task.description,
      count: task.target || 1,
      metric: task.metric || "",
      completed: false,
      createdAt: new Date().toISOString()
    });
    printToTerminal("Task added to your quests!", "success");
    windowSystem.closeWindow("taskSuggestionWindow");
  };

  document.getElementById("declineTask").onclick = () => {
    windowSystem.closeWindow("taskSuggestionWindow");
  };

  // Handle close button
  window.querySelector(".window-close").onclick = () => {
    windowSystem.closeWindow("taskSuggestionWindow");
  };
}
Explanation:

createQuest integrates the task into the existing quest system.
Default values (e.g., count: 1) ensure compatibility if Target is missing.
The close button provides an alternative to "Decline."
Step 8: Connect the AI Call to the Workflow
Objective: Tie together mood input, AI processing, and window display.

Instructions:

Define callAIForSuggestion to call the AI and handle the response.
Use constructPrompt, call the API, parse the response, and show the window.
Code Example:








async function callAIForSuggestion(userData) {
  try {
    const prompt = constructPrompt(userData);
    const aiResponse = await window.soloAISystem.callDeepSeekAPI(prompt);
    const task = parseTaskSuggestion(aiResponse);
    showTaskSuggestion(task);
  } catch (error) {
    printToTerminal(`Failed to generate task: ${error.message}`, "error");
  }
}
Explanation:

try/catch ensures errors (e.g., API failure) don’t crash the app.
The workflow progresses logically from data to AI to UI.
Step 9: Handle Edge Cases
Objective: Ensure robustness against unexpected scenarios.

Instructions:

Add checks for invalid mood inputs in handleMoodSuggestion.
Handle missing user data in userData construction (already done with defaults).
Provide a fallback if the AI response is invalid.
Code Example:








if (!mood.match(/^[a-zA-Z\s]+$/)) {
  printToTerminal("Mood should contain only letters and spaces.", "warning");
  return;
}

// In parseTaskSuggestion, add a fallback
if (!task.title || !task.description) {
  return {
    title: "Take a Moment",
    description: "Relax and reassess your mood",
    target: 5,
    metric: "minutes"
  };
}
Explanation:

Input validation prevents malformed data from reaching the AI.
A fallback task keeps the feature functional even if the AI fails.
Step 10: Test the Feature
Objective: Verify functionality across various scenarios.

Instructions:

Test with moods: "happy," "stressed," "tired," "bored."
Test with different playerStats configurations (e.g., no age, high level).
Test edge cases: empty mood, API downtime, malformed AI response.
Confirm tasks appear in questsWindow after acceptance.
Checklist:

 Mood input triggers prompt.
 AI generates relevant tasks.
 Window displays correctly with buttons.
 Accepted tasks sync to Firebase and UI.
Step 11: Refine Based on Feedback
Objective: Improve the feature post-implementation.

Instructions:

Collect user feedback on task relevance and usability.
Adjust the AI prompt (e.g., add more examples) if tasks feel off.
Consider a cooldown (e.g., limit !mood to once every 10 minutes).
Example Adjustment:








let lastMoodTime = 0;
commands["!mood"] = () => {
  if (Date.now() - lastMoodTime < 600000) { // 10 minutes
    printToTerminal("Please wait before requesting another suggestion.", "warning");
    return;
  }
  lastMoodTime = Date.now();
  awaitingMood = true;
  printToTerminal("Enter your current mood:", "info");
};
Conclusion
This guide provides a meticulous, step-by-step roadmap for integrating the mood-based task suggestion feature into our project. By following these instructions, another AI or developer can implement the feature with confidence, leveraging the existing terminal, AI, window, and quest systems. The result will be a robust, user-friendly addition that enhances productivity and engagement.

This Mood-Feature-Context.md file is now ready to be added to your project documentation. Let me know if you need help coding specific parts or integrating it further!